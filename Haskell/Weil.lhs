> {-# LANGUAGE ScopedTypeVariables #-}
> module Weil where
>
> import CDGA (deriv, singleTerm, deg, singleTerm, closed, values_, sumCombination, canonicalize, Degreed, Derivable)
> import qualified CDGA
> import qualified Data.Map as Map
> import Data.Map (Map)

Here we implement the Weil algebra, given a list of generators.
A value (a, False) is the non-shifted version; (a, True) is the verson with shifted degee.
(We implement it in this way to facilitate deriving Enum and Bounded.)

The deriving clause means that all Deltas are sorted after all the Ids.

> data Weil a = Id a | Delta a deriving (Eq, Ord)

We need to implement Enum and Bounded so tht we can automatically enumerate all (non-bottom) values of this type. The formula is fromEnum(a) + (if Delta, then # of instances of type a).

> instance Bounded a => Bounded (Weil a) where
>   minBound = Id minBound
>   maxBound = Delta maxBound
>
> instance forall a. (Enum a, Bounded a) => Enum (Weil a) where
>   fromEnum (Id x) = fromEnum x
>   fromEnum (Delta x) = fromEnum x + 1 + fromEnum (maxBound :: a)
>   toEnum n
>     | n <= fromEnum (maxBound :: a) = Id $ toEnum n
>     | otherwise = Delta . toEnum $ n - 1 - fromEnum (maxBound :: a)
>   enumFrom     x   = enumFromTo     x maxBound
>   enumFromThen x y = enumFromThenTo x y bound
>     where
>     bound | fromEnum y >= fromEnum x = maxBound  
>           | otherwise                = minBound

> delta :: Num t => Weil a -> Map [Weil a] t
> delta (Id a) = Map.singleton [Delta a] 1
> delta (Delta a) = Map.empty

> instance Degreed a => Degreed (Weil a) where
>   deg (Id a) = deg a
>   deg (Delta a) = deg a + 1
> instance Show a => Show (Weil a) where
>   show (Id a) = show a
>   show (Delta a) = "Î´" ++ show a
> instance (Ord a, Derivable a) => Derivable (Weil a) where
>   deriv (Id a) = canonicalize $ Map.mapKeys (map Id) (deriv a) + singleTerm (Delta a)
>   deriv (Delta a) = canonicalize $ CDGA.derivGen delta $ Map.mapKeys (map Id) (deriv a)

Now, we need to implement the algebra of invariants. These are the elements of the Weil algebra, generated by Deltas alone, that have vanishing derivatives. Well, if we have bosonic generators, this may be infinite. Also, we need to check for reducibility etc.

Basically the same routines as in Example.lhs.

> invariant_ :: (Fractional t, Eq t, Ord a, Bounded a, Enum a, Derivable a) => a -> Integer -> [Map [Weil a] t]
> invariant_ a n = closed . sumCombination n deg . map Delta . values_ $ a

